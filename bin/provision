#!/usr/bin/env perl

package Trog::Bin::Provisioner;

use strict;
use warnings;

use Cwd qw{abs_path};
use FindBin;
use Config::Simple();
use File::Slurper();
use File::Copy();
use YAML::XS();
use JSON::PP();
use List::Util qw{any uniq};
use File::Which qw {which};
use Getopt::Long qw{GetOptionsFromArray};
use Net::OpenSSH::More;
use Net::EmptyPort;
use XML::Twig;
use JSON::MaybeXS;

sub _coerce_array {
    return \@_;
}

#TODO: cpu/gpu passthru accel via techniques such as the following:
# https://github.com/HarbourHeading/KVM-GPU-Passthrough

our $domain_dir;
our $dryrun;
sub main {
    my @args = @_;

    my ($reuse);
    GetOptionsFromArray(\@args,
        'existing=s'  => \$reuse,
        'domaindir=s' => \$domain_dir,
        'dryrun'      => \$dryrun,
    );

    my $domain = shift @args;
    die "No domain passed" unless $domain;

    $domain_dir //='/opt/domains';

    $domain =~ s/\///g;
    my $cfile = "$domain_dir/$domain/provision.conf";
    die "No such file provision.conf in $domain_dir/$domain/" unless -f $cfile;

    my $udf = "$domain_dir/$domain/users.yaml";
    die "User definition file $domain_dir/$udf not present!" unless -f $udf;

    die "Terraform not installed" unless which('terraform');

    # Basic setup
    mkdir '/opt/terraform';
    mkdir '/opt/terraform/disks';
    mkdir '/opt/terraform/config';

    my $config = Config::Simple->new($cfile);
    my $reuser = $config->param('admin_user') // 'root';

    my $data = "$domain_dir/$domain/data.tar.gz";
    die "No data to host in $domain/" unless -f $data;
    # Stash domain dir in config object for later use
    $config->param('domain_dir', $domain_dir);

    # Fix the terraform state.
    # We have to do this every time, for every single known domain.
    # This is because there is NO GUARANTEE that the tfstate is in sync with actual libvirt state.
    my $statefile  = "/opt/terraform/config/terraform.tfstate";
    my $tf_domains = get_tf_managed_domains($statefile);
    my %volatile   = extract_volatile_libvirt_info($tf_domains);
    brainwash_tfstate($statefile, %volatile);

    # Now, let's figure out if this has a VM which needs to be built first.
    # In the event reuse is passed, we are just layering configs really.
    my $skey = "$domain_dir/$domain/key.rsa";
    my $depends = $config->param('depends_on');
    if ($depends) {
        print "$domain depends on $depends, provisioning that first...\n";
        my $dcfile = "$domain_dir/$depends/provision.conf";
        die "No such file provision.conf in $domain_dir/$depends/" unless -f $cfile;
        my $dconfig = Config::Simple->new($dcfile);

        #XXX should probably die here if the admin_users differ!

        $skey = "$domain_dir/$depends/key.rsa";
        ($reuser, $reuse) = provision_domain($dconfig, $depends, $reuse, $reuser);
        if (!$dryrun) {
            my $ssh = wait_for_ssh($reuser, $skey, $reuse) or die "$depends never came up";
            wait_for_cloud_init($ssh);
            wait_for_makefile($ssh, $depends);
        }

    }
    #TODO need to figure out how to apply the cloud-init for the second domain if deps are active
    my ($user, $ip) = provision_domain($config, $domain, $reuse, $reuser, $depends);
    return 0 if $dryrun;

    my $ssh = wait_for_ssh($user, $skey, $ip) or die "$domain never came up";
    wait_for_cloud_init($ssh);
    wait_for_makefile($ssh, $domain);

    return 0;
}

sub wait_for_cloud_init {
    my ($ssh, $t) = @_;

    # TODO make configurable
    $t //= '30m';
    print "Waiting up to $t for Cloud-init to finish...\n";
    my $rc = $ssh->cmd_exit_code(qq{sudo timeout $t bash -c 'until grep "Boot configuration complete." /var/log/cloud-init-output.log; do sleep 1; done;'});
    print "Done!\n";
    die "Cloud init reported failure! Investigate machine." if $rc;
}

sub wait_for_makefile {
    my ($ssh, $domain, $t) = @_;

    # TODO make configurable
    $t //= '30m';

    print "Waiting up to $t for ATD queue to flush...\n";
    my $out = $ssh->cmd(qq{sudo timeout $t bash -c 'until [ \$(atq | wc -l) = 0 ]; do sleep 1; done;'});

    print "Waiting up to $t for Makefile payload to start...\n";
    $ssh->cmd_exit_code(qq{sudo timeout $t bash -c 'until [ -f /var/log/$domain.setup.log ]; do sleep 1; done;'});


    print "Waiting up to $t for Makefile payload to finish...\n";
    $ssh->cmd_exit_code(qq{sudo timeout $t bash -c 'while lsof | grep /var/log/$domain.setup.log; do sleep 1; done;'});

    print "Waiting up to $t for any makefile queued ATD jobs to flush...\n";
    $out = $ssh->cmd(qq{sudo timeout $t bash -c 'until [ \$(atq | wc -l) = 0 ]; do sleep 1; done;'});

    print "Last log:\n";
    print $ssh->cmd(qq{sudo tail /var/log/$domain.setup.log});

    print "\nDone!\n";
}

sub provision_domain {
    my ($config, $domain, $reuse, $reuser, $depends) = @_;

    my $domain_mongled = $domain;
    $domain_mongled =~ s/\./-/g;

    # Set this to simplify calling conventions
    $config->param('domain', $domain);
    my $domain_dir = $config->param('domain_dir');

    my $nc = mongle_network_configuration($config);
    print "Wrote $nc\n";

    my $ss = mongle_setup_script($config);
    print "Wrote $ss\n";

    my $lc = mongle_logging_config($config);
    print "Wrote $lc\n";

    my $cc = mongle_cloud_init($config);
    print "Wrote $cc\n";

    # If the domain is already up, let's find the IP.
    # We can't guarantee we have a static IP, so use the internal.
    my $qdn = $domain;
    $qdn = $depends if $depends;
    $qdn =~ s/\.\S+$//;

    #XXX this can be fooled if you have two VMs, one a subdo of the other
    my $old_ip = qx#virsh net-dhcp-leases default | grep $qdn | awk '{print \$5}' | sed -E s/\\\\/[0-9]+\$//#;
    $old_ip = 'bogus' unless $old_ip;
    chomp $old_ip;

    if ($reuse) {
        return ($reuser, $old_ip) if $dryrun;
        #$old_ip = $reuse;

        # Re-Use the existing VM, and just ship over what we got and run the makefile again.
        my %opts = ( host => $old_ip );
        $opts{user}     = $reuser;

        # Make sure any existing VMs don't have this domain
        clean_domain_resources($domain_mongled);
        unlink "/opt/terraform/config/$domain.tf";

        # Try to use the root key if no admin user is passed (this may not work if you locked down the box!)
        # Otherwise we'll use the agent.
        $opts{key_path} = "$domain_dir/$domain/key.rsa";
        $opts{key_path} = "$domain_dir/$depends/key.rsa" if $depends;
        print "Attempting to access Machine\n";
        my $ssh = Net::OpenSSH::More->new(%opts);

        my $output = '';
        print "Installing Updated cloud-init and forcing re-run...\n";
        my $init = "/opt/terraform/config/$domain.cloud_init.cfg";
        my $ci_dir = "/var/lib/cloud/instances/nocloud";
        $ssh->sftp->put($init, 'cloud-config.txt');
        # Remove the semaphore that says this was run, then run the needed targets
        $ssh->cmd("rm $ci_dir/sem/cc_package_update_upgrade_install");
        ($output) = $ssh->cmd("sudo cloud-init single --name cc_package_update_upgrade_install -f cloud-config.txt");
        print "$output\n";
        $ssh->cmd("rm $ci_dir/sem/cc_users_groups");
        ($output) = $ssh->cmd("sudo cloud-init single --name cc_users_groups -f cloud-config.txt");
        print "$output\n";

        my $ips  = _coerce_array($config->param('ips'));
        my ($existing_nc) = $ssh->cmd("sudo cat /etc/netplan/50-cloud-init.yaml");
        my $parsed = YAML::XS::Load($existing_nc);
        my $num_ips = scalar(@{$parsed->{network}{ethernets}{enp2s0}{addresses}});
        @{$parsed->{network}{ethernets}{enp2s0}{addresses}} = uniq(@{$parsed->{network}{ethernets}{enp2s0}{addresses}}, map { "$_/24"} @$ips);
        if ($num_ips != scalar(@{$parsed->{network}{ethernets}{enp2s0}{addresses}})) {
            my $encoded = YAML::XS::Dump($parsed);
            my $new_config = "$domain_dir/$domain/network-config-merged.yaml";
            File::Slurper::write_text($new_config, $encoded);
            print "Setting up IP for $domain...\n";
            $ssh->sftp->put($new_config, "network-config-merged.yaml");
            $ssh->cmd("sudo mv network-config-merged.yaml /etc/netplan/50-cloud-init.yaml");
            $ssh->cmd("sudo chmod 0600 /etc/netplan/50-cloud-init.yaml");
            $ssh->cmd("sudo chown root:root /etc/netplan/50-cloud-init.yaml");
            ($output) = $ssh->cmd("sudo netplan apply");
            chomp $output;
            print "$output\n" if $output;
        }

        print "Syncing setup script\n";
        my $res = $ssh->sftp->put( "$domain_dir/$domain/setup.sh", "setup-$domain.sh" );
        $ssh->cmd("chmod +x setup-$domain.sh");
        $ssh->cmd("sudo mv setup-$domain.sh /root");
        print "Scheduling job to run setup script\n";
        ($output) = $ssh->cmd("sudo at now -f /root/setup-$domain.sh");
        print $output;
        print "Done.\n";
        return ($reuser, $old_ip);
    }

    # TODO move the deletion of unneeded resources above the SSH reuse stuff, remove dependent VMs from conf.
    my $tf = mongle_terraform_template($config);
    print "Wrote $tf\n";

    return ($config->param('admin_user'), $old_ip) if $dryrun;

    chdir "/opt/terraform/config";
    # Figure out if we need to liquidate/respawn/spawn existing stuff
    my $result = 0;
    # If something named this domain exists, but is supposed to depend on something else, destroy it.
    clean_domain_resources($domain_mongled);

    system(qw{terraform init});
    system(qw{terraform plan -out tf.plan});
    system(qw{terraform apply tf.plan});
    $result = $? >> 8;
    die "Terraform cried uncle" if $result;

    # If we're not re-using the VM, waste the old DHCP lease, so we don't fill up the table and gum everything up.
    my $nuked = qx#VIR_BRIDGE_NAME=virbr0 /usr/libexec/libvirt_leaseshelper del ip $old_ip#;
    print qq#VIR_BRIDGE_NAME=virbr0 /usr/libexec/libvirt_leaseshelper del ip $old_ip\n#;

    print "Waiting for VM to come live...";
    my $new_ip='';
    my $oldip_grep = "| grep -v $old_ip";
    for (1..30) {
        $new_ip = qx#virsh net-dhcp-leases default | grep $qdn $oldip_grep | awk '{print \$5}' | sed -E s/\\\\/[0-9]+\$//#;
        print qq#virsh net-dhcp-leases default | grep $qdn $oldip_grep | awk '{print \$5}' | sed -E s/\\\\/[0-9]+\$//\n#;
        chomp $new_ip;
        last if $new_ip && ($new_ip ne $old_ip);
        print ".";
        sleep 1;
    }
    print "\nVM never came up!\n" unless $new_ip;
    print "\nAll Done!  The server should be live at $new_ip\n";

    return ($config->param('admin_user'), $new_ip);
}

sub clean_domain_resources {
    my ($domain_mongled) = @_;
    my @exempt = qw{libvirt_volume.image_base libvirt_pool.tf_disks};
    my $resources = qx{terraform state list};
    chomp $resources;
    foreach my $resource (split(/\n/, $resources)) {
        next unless $resource =~ m/\Q$domain_mongled\E/;
        next if any { $_ eq $resource } @exempt;
        print "Terminating $resource\n";
        #XXX terraform has no good means to say "HEY THESE ARE SHARED RESOURCES HANDS OFF!"
        #XXX So we have to instead painstakingly kill everything that isn't.
        #XXX they claim modules are the way to do this, but that appears to be false.
        #XXX Maybe I have to instead make both the shared and vm specific stuff modules? IDK
        system(qw{terraform destroy -auto-approve -target}, $resource) unless any { $_ eq $resource } @exempt;
    }
}

sub wait_for_ssh {
    my ($user, $key, $ip) = @_;
    print "Waiting for $ip:22 to come live...\n";
    my $wait = 300;
    my $ssh_up = Net::EmptyPort::wait_port({ host => $ip, port => 22, max_wait => $wait });
    die "SSH port never came up after $wait seconds!" unless $ssh_up;

    # Make sure we can *actually* SSH in
    my $ssh = Net::OpenSSH::More->new( host => $ip, user => $user, key_path => $key );
    die "Could not establish SSH connection as $user!" unless $ssh;
}

sub mongle_terraform_template {
    my ($config) = @_;

    my $domain = $config->param('domain');
    my $image  = $config->param('image');
    my $disk_size = $config->param('size');
    #my $user      = $config->param('admin_user');
    #my $pkey_loc  = $config->param('pkey_loc');

    #die "Require admin_user & valid private key location (pkey_loc) to continue" unless $user && -f $pkey_loc;

    my $bridge_device = qx/brctl show | grep -vP 'vnet|virbr' | tail -n1 | awk '{print \$1}'/;
    die "Could not determine outbound bridge device!" unless $bridge_device;
    chomp $bridge_device;
    print "Using outbound bridge $bridge_device\n";

    # OK, let's get the UUID of our storage pool IN CASE we are re-using it
    my $pool_info = qx/virsh pool-list --uuid --name --all/;
    my %pools;
    open my $pd, '<', \$pool_info;
    foreach my $line (<$pd>) {
        my ($k,$v) = $line =~ m/^\s*(\S+)\s+(\S+)\s*$/;
        $pools{$v} = $k if $v;
    }
    close $pd;

    my $imagedir = "$domain_dir/$domain";
    # TODO make this configurable so we can use lvm
    my $libvirt_pool = $pools{tf_disks};
    my ($import_block, $image_block) = ('', '');
    if ($libvirt_pool) {
        print "Re-Using existing libvirt pool $libvirt_pool\n";
        $import_block = qq|
import {
    to = libvirt_pool.tf_disks
    id = "$libvirt_pool"
}
|;
    }

    my $domain_mongled = $domain;
    $domain_mongled =~ s/\./-/g;

    my %to_mongle = (
        'main.tmpl'   => "config/main.tf",
        'domain.tmpl' => "config/$domain.tf",
    );

    my @files_mongled;
    foreach my $file (keys(%to_mongle)) {
        my $tf_template = File::Slurper::read_text("$FindBin::Bin/../$file");

        $tf_template =~ s/%BRIDGENAME%/$bridge_device/gmx;
        $tf_template =~ s/%REPLACEME%/$domain/gmx;
        $tf_template =~ s/%MONGLED%/$domain_mongled/gmx;
        $tf_template =~ s/%GIGGLEBYTES%/$disk_size/gmx;
        #$tf_template =~ s/%USER%/$user/gmx;
        #$tf_template =~ s/%PKEY_LOC%/$pkey_loc/gmx;
        $tf_template =~ s/%CLOUDIMG%/$image/gmx;
        $tf_template =~ s/%LIBVIRT_POOL_IMPORT%/$import_block/gmx;
#        $tf_template =~ s/%BASE_IMAGE_IMPORT%/$image_block/gmx;

        my $tfile = "/opt/terraform/$to_mongle{$file}";
        File::Slurper::write_text($tfile, $tf_template);
        push(@files_mongled, $tfile);
    }

    #XXX tf plugin should do this automatically, but does not
    unlink "/opt/terraform/disks/commoninit.iso";

    return join(', ', @files_mongled);
}

# Slam in the IPs, gw, resolvers
sub mongle_network_configuration {
    my $config = shift;

    my $domain = $config->param('domain');
    my $ips  = _coerce_array($config->param('ips'));
    my $gw   = $config->param('gateway');
    my $res  = _coerce_array($config->param('resolvers'));

    # We need two adapters, one on virbr0 and another on the bridge.
    # So, we need to figure out:
    # 1. IP of the virbr
    # 2. name of the bridge device.
    # 3. IP of bridge device.

    my $virbr_device = qx/brctl show | grep virbr | tail -n1 | awk '{print \$1}'/;
    die "Could not determine libvirt network device!" unless $virbr_device;
    chomp $virbr_device;
    print "Using libvirt network device $virbr_device\n";

    my $virbr_ip = qx/ip addr show dev $virbr_device | grep inet | head -n1 | awk '{print \$2}'/;
    die "Could not determine IP address for $virbr_device" unless $virbr_ip;
    chomp $virbr_ip;
    $virbr_ip =~ s/\/\d\d$//;
    print "HV internal IP: $virbr_ip\n";

    # Stash this in the config object for later use by the clown-config
    $config->param('hv_internal_ip', $virbr_ip);

    # Such an astonishingly tedious format
    my @subnets = map {
        {
            type      => 'static',
            address   => $_,
            gateway   => $gw,
            dns_nameservers => $res,
            dns_search      => [$domain],
        }
    } @$ips;

    # Do DHCP if no IP was supplied
    if (!@subnets) {
        @subnets = (
            {
                type => 'dhcp',
            }
        );
    }

    my $netconf = {
       network => {
            version => 1,
            config  => [
                {
                    type => 'physical',
                    name => 'enp2s0',
                    subnets => \@subnets,
                    gateway4 => $gw,
                    nameservers => {
                        search => [$domain],
                        addresses => $res,
                    }
                },
                {
                    type => 'physical',
                    name => 'enp1s0',
                    subnets => [
                        {
                            type => 'dhcp',
                        },
                    ],
                },
            ],
       },
    };

    my $cf = "/opt/terraform/config/$domain.network_config.cfg";
    File::Slurper::write_text($cf, YAML::XS::Dump($netconf));
    return $cf;
}

sub inject_admin_key {
    my ($admin_user, $domain, $config, $pubkey) = @_;
    # Don't bother if we aren't setting this up.
    return unless $admin_user;
    return unless ref $config->{users} eq 'ARRAY';

    foreach my $u (@{$config->{users}}) {
        next unless exists $u->{name};
        next unless $u->{name} eq $admin_user;
        $u->{ssh_authorized_keys} //= [];
        push(@{$u->{ssh_authorized_keys}}, $pubkey);
        return;
    }
    return;
}

# Generate and store a new SSH key for the guest, which we will authorize on the HV to grab the data.tar.gz
sub mongle_cloud_init {
    my $config = shift;

    my $domain = $config->param('domain');
    my $contactemail = $config->param('contact_email');
    my $user = getpwuid($<);

    # Generate a new key for the child
    qx{yes | ssh-keygen -t rsa -f $domain_dir/$domain/key.rsa -N ''};
    die "No key generated!" unless -f "$domain_dir/$domain/key.rsa";
    die "No pubkey generated!" unless -f "$domain_dir/$domain/key.rsa.pub";
    chmod 0600, "$domain_dir/$domain/key.rsa";
    chmod 0600, "$domain_dir/$domain/key.rsa.pub";

    # Authorize the key with the transfer user.
    my $pubkey = File::Slurper::read_text("$domain_dir/$domain/key.rsa.pub");
    chomp $pubkey;
    open(my $fh, '>>', "$ENV{HOME}/.ssh/authorized_keys");
    print $fh "$pubkey\n";
    close($fh);

    my $pkgs = _coerce_array($config->param('packages'));
    # We absolutely must have atd, sendmail and make.
    push(@$pkgs, 'sendmail') unless any { $_ eq 'postfix' } @$pkgs;
    push(@$pkgs, qw{at make});
    @$pkgs = uniq @$pkgs;

    my $udf = "$domain_dir/$domain/users.yaml";
    my $userdefs = YAML::XS::Load(File::Slurper::read_text($udf));

    # Inject the SSH key for access into the admin_user's SSH
    inject_admin_key($config->param('admin_user'), $domain, $userdefs, $pubkey);

    $YAML::XS::Boolean = "JSON::PP";
    my $clown_config = {
        runcmd => [
            qq{echo "root:$contactemail\n" > /etc/aliases },
            "at now -f /root/setup.sh",
        ],
        packages => $pkgs,
        users => $userdefs->{users},
        fqdn => $domain,
        manage_etc_hosts => 'localhost',
        final_message => "Boot configuration complete.",
        # Make sure root can scp to/from the transfer user on the HV, and we start shipping logs.
        write_files => [
            {
                content     => File::Slurper::read_text("$domain_dir/$domain/key.rsa"),
                path        => "/root/.ssh/id_rsa",
                owner       => "root:root",
                permissions => '0600',
                defer       => $JSON::PP::true,
            },
            {
                content     => File::Slurper::read_text("$domain_dir/$domain/key.rsa.pub"),
                path        => "/root/.ssh/id_rsa.pub",
                owner       => "root:root",
                permissions => '0600',
                defer       => $JSON::PP::true,
            },
            {
                content     => File::Slurper::read_text("$domain_dir/$domain/setup.sh"),
                path        => "/root/setup.sh",
                owner       => "root:root",
                permissions => "0775",
                defer       => $JSON::PP::true,
            },
        ],
        rsyslog => {
            install_rsyslog => $JSON::PP::true,
            config_dir => '/etc/rsyslog.d',
            configs => [{
                filename => '10-ship_logs_to_hv.conf',
                content  => File::Slurper::read_text("$domain_dir/$domain/rsyslog.conf"),
             }]
        }
    };
    my $cf = "/opt/terraform/config/$domain.cloud_init.cfg";
    File::Slurper::write_text($cf, "#cloud-config\n".YAML::XS::Dump($clown_config));
    return $cf;
}

sub mongle_setup_script {
    my $config = shift;
    my $domain = $config->param('domain');
    my $hvip   = $config->param('hv_internal_ip');
    my $pre_make_script = $config->param('pre_make_script');

    my ($username) = getpwuid($<);

    my $script_template = File::Slurper::read_text("$FindBin::Bin/../setup.tmpl");
    $script_template =~ s/%THISIP%/$hvip/gmx;
    $script_template =~ s/%DOMAIN%/$domain/gmx;
    $script_template =~ s/%THISDIR%/$domain_dir/gmx;
    $script_template =~ s/%USER%/$username/gmx;
    $script_template =~ s/%PRE_MAKE%/$pre_make_script/gmx if $pre_make_script;

    my $sf = "$domain_dir/$domain/setup.sh";
    File::Slurper::write_text($sf, $script_template);
    return $sf;
}

# Make this VM send its rsyslog to here, or wherever is setup correctly
sub mongle_logging_config {
    my $config = shift;
    my $domain = $config->param('domain');
    my $ship_to = $config->param('hv_internal_ip');

    my $local_config_template = File::Slurper::read_text("$FindBin::Bin/../rsyslog.tmpl");
    $local_config_template =~ s/%DOMAIN%/$domain/gmx;

    # Write the local rsyslog conf
    my $lcf = "/etc/rsyslog.d/10-$domain.conf";
    File::Slurper::write_text($lcf, $local_config_template);

    # Write the local rsyslog logrotate conf
    File::Copy::copy("$FindBin::Bin/../rsyslog-logrotate.tmpl", "/etc/logrotate.d/vms.conf");

    #TODO die if these fail
    system(qw{systemctl restart rsyslog});

    my $config_template = File::Slurper::read_text("$FindBin::Bin/../rsyslog-guest.tmpl");
    $config_template =~ s/%LOGHOST%/$ship_to/gmx;

    my $lf = "$domain_dir/$domain/rsyslog.conf";
    File::Slurper::write_text($lf, $config_template);
    return $lf;
}

sub get_tf_managed_domains {
    my ($statefile) = @_;
    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);

    my $parsed = $json->decode(File::Slurper::read_text($statefile));

    my @domains;
    foreach my $res (@{$parsed->{resources}}) {
        next unless $res->{type} eq 'libvirt_domain';
        push(@domains, $res->{name});
    }
    return \@domains;
}

sub extract_volatile_libvirt_info {
    my ($domains) = @_;

    my %info;
    my $domain;

    my $extract_console = sub {
        my ($t, $section) = @_;

        my $source = $section->first_child('source');
        my $target  = $section->first_child('target');
        my $name  = $target ? $target->att('type') : '';
        $info{$domain}{$name} = $source->att('path') if $source && $name;
        $section->purge();
    };

    my $extract_graphics = sub {
        my ($t, $section) = @_;
        my $type = $section->att('type');
        $info{$domain}{$type} = $section->att('port');
        $section->purge();
    };

    my $xml = XML::Twig->new(
        twig_roots => {
            'console'  => $extract_console,
            'graphics' => $extract_graphics,
        },
        twig_print_outside_roots => 0,
    );

    foreach my $mongled (@$domains) {
        $domain = $mongled;
        $domain =~ s/-/\./g;

        # First, see if the domain is up.  If it's not, we don't care.
        my $state = `virsh dominfo $domain | grep 'State'`;
        next if $state !~ m/running/i;

        my $raw = `virsh dumpxml $domain 2>&1`;
        return () if $raw =~ m/failed to get domain/;
        $domain = $mongled;
        $xml->parse($raw);
    }

    return %info;
}

# I AM YURI. YOU WILL OBEY ME.
sub brainwash_tfstate {
    my ($statefile, %opts) = @_;

    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);

    my $parsed = $json->decode(File::Slurper::read_text($statefile));

    foreach my $mongled (keys %opts) {
        foreach my $res (@{$parsed->{resources}}) {
            next unless $res->{type} eq 'libvirt_domain';
            next unless $res->{name} eq $mongled;
            foreach my $instance (@{$res->{instances}}) {
                if (exists $instance->{attributes}{devices}{consoles}) {
                    foreach my $console (@{$instance->{attributes}{devices}{consoles}}) {
                        $console->{source} = $opts{$mongled}{$console->{target_type}} if $opts{$mongled}{$console->{target_type}};
                    }
                }
                $instance->{attributes}{devices}{graphics}{vnc}{port}   = $opts{$mongled}{vnc}   if $opts{$mongled}{vnc};
                $instance->{attributes}{devices}{graphics}{spice}{port} = $opts{$mongled}{spice} if $opts{$mongled}{spice};
            }
        }
    }
    File::Copy::copy($statefile, "$statefile.bak");
    my $encoded = $json->encode($parsed);
    File::Slurper::write_text($statefile, $encoded);
    print "Overwrote $statefile with current VM socket state, old saved as $statefile.bak\n";
    return 1;
}

exit main(@ARGV) unless caller;

1;
