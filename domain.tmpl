resource "libvirt_volume" "%MONGLED%-qcow2" {
    name = "%REPLACEME%-qcow2"
    pool = libvirt_pool.tf_disks.name
    backing_store = {
  	    path = libvirt_volume.image_base.path
        format = "qcow2"
    }
    format   = "qcow2"
    capacity = %GIGGLEBYTES%
    depends_on = [libvirt_volume.image_base]
}

data "template_file" "user_data_%MONGLED%" {
  template = file("${path.module}/%REPLACEME%.cloud_init.cfg")
}

data "template_file" "network_config_%MONGLED%" {
  template = file("${path.module}/%REPLACEME%.network_config.cfg")
}

resource "libvirt_cloudinit_disk" "commoninit_%MONGLED%" {
  name           = "%MONGLED%_commoninit.iso"
  user_data      = data.template_file.user_data_%MONGLED%.rendered
  network_config = data.template_file.network_config_%MONGLED%.rendered
  meta_data      = yamlencode({
    instance-id = "%REPLACEME%"
    local-hostname = "%REPLACEME%"
  })
}

resource "libvirt_volume" "cloudinit_%MONGLED%" {
  name   = "cloudinit_%MONGLED%"
  pool   = libvirt_pool.tf_disks.name
  format = "iso"

  create = {
    content = {
      url = libvirt_cloudinit_disk.commoninit_%MONGLED%.path
    }
  }
}

resource "libvirt_domain" "%MONGLED%" {
	name   = "%REPLACEME%"
	memory = "4092"
	unit   = "MiB"
	vcpu   = 2
	type   = "kvm"
	running = true
	autostart = true

	features = {
		acpi = true
		apic = true
		ioapic_driver = "kvm"
		hap = "on"
		pae = true
	}

	os = {
		type = "hvm"
		arch = "x86_64"
		machine = "q35"
		boot_devices = ["hd"]
	}

    devices = {

		interfaces = [
			{
				type  = "network"
				model = "virtio"
				source = {
					network = "default"
				}
				wait_for_ip = {
					source  = "lease"
					timeout = 300
				}
			},
			{
				type   = "bridge"
				model  = "virtio"
				source = {
					bridge = "%BRIDGENAME%"
				}
			}
		]

		disks = [
		  {
			source = {
				pool = "tf_disks"
				volume = libvirt_volume.%MONGLED%-qcow2.name
			}
			target = {
				dev = "vda"
				bus = "virtio"
			}
			device = "disk"
		  },
		  {
			source = {
				file = libvirt_cloudinit_disk.commoninit_%MONGLED%.path
			}
			target = {
				#XXX THIS BLOWS UP IF YOU SPECIFY 'cdrom' PROPERLY!!!
				dev = "sda"
				bus = "sata"
			}
			device = "cdrom"
		  }
		]

		# IMPORTANT: this is a known bug on cloud images, since they expect a console
		# we need to pass it
		# https://bugs.launchpad.net/cloud-images/+bug/1573095
		consoles = [
			{
				type        = "pty"
				target_port = "0"
				target_type = "serial"
			},
			{
				type        = "pty"
				target_type = "virtio"
				target_port = "1"
			}
		]
		graphics = {
		    vnc = {
			    autoport = "yes"
		    }
		}
		video = {
			type = "virtio"
		}
	}
}
